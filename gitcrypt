#!/usr/bin/env sh

readonly VERSION="0.4.1"
readonly DEFAULT_CIPHER="aes-256-cbc"

[ -z "$GIT_DIR" ] && GIT_DIR=".git"

die() {
    echo "Error: $@"
    exit -1
}

check_distr() {
    which "$1" &> /dev/null || die "$1 not found in PATH - check gitcrypt distribution"
}

check_distr "gitcrypt-restore-key"
check_distr "gitcrypt-merge"
check_distr "gitcrypt-watchdog"
check_distr "gitcrypt-filter"

_disable() {
    _debug "=> Disabling gitcrypt facility"
    git config --unset filter.encrypt.smudge
    git config --unset filter.encrypt.clean
    git config --unset filter.encrypt.required
    git config --unset diff.encrypt.textconv

    git config --unset merge.encrypt.name
    git config --unset merge.encrypt.driver
    git config --remove-section filter.encrypt &> /dev/null
    git config --remove-section diff.encrypt &> /dev/null
    git config --remove-section merge.encrypt &> /dev/null
}

_enable() {
    _debug "=> Enabling gitcrypt facility"
    git config filter.encrypt.smudge "gitcrypt smudge"
    git config filter.encrypt.clean "gitcrypt clean"
    git config filter.encrypt.required
    git config diff.encrypt.textconv "gitcrypt diff"

    git config merge.encrypt.name "gitcrypt merge driver"
    git config merge.encrypt.driver "gitcrypt-merge %A %O %B %L"
}

_debug() {
    [ -z "$GITCRYPTDEBUG" ] || echo -e "GCDBG: ${GDBGTAB} ${1}"
}

init_config() {
    local answer

    if [ ! -d "$GIT_DIR" ]; then
        echo "Directory is not a git repository. Did you forget to run 'git init'?"
        return 1
    fi

    while [ 1 ]; do
        while [ -z "$SALT" ]; do
            echo -n "Generate a random salt? [Y/n] "
            read answer

            case "$answer" in
                n*|N*)
                    echo -n "Shared salt as hex characters: "
                    read SALT

                    if [ $(echo "$SALT" | grep '[^a-f0-9]' | wc -l) -ne 0 ]; then
                        echo "Error: non-hex characters in salt"
                        unset -v SALT
                    fi
                    ;;
                *)
                    local md5=$(which md5 2>/dev/null || which md5sum 2>/dev/null)
                    SALT=$(head -c 10 < /dev/random | $md5 | cut -c-16)
                    ;;
            esac
        done

        while [ -z "$PASS" ]; do
            echo -n "Generate a random password? [Y/n]"
            read answer

            case "$answer" in
                n*|N*)
					echo -n "Enter your passphrase or path to rsa-private key(ex ~/.ssh/id_rsa): "
                    read PASS
            		[ -z "$PASS" ] && PASS="~/.ssh/id_rsa"
                    ;;
                *)
                    PASS=$(cat /dev/urandom | LC_ALL="C" tr -dc '!@#$%^&*()_A-Z-a-z-0-9' | head -c32)
                    ;;
            esac
        done

        while [ 1 ]; do
            echo -n "What encryption cipher do you want to use? [$DEFAULT_CIPHER] "
            read CIPHER
            [ -z "$CIPHER" ] && CIPHER="$DEFAULT_CIPHER"

            local exists
            exists=$(openssl list-cipher-commands | grep "$CIPHER")
            [ $? -eq 0 ] && break

            echo "Error: Cipher '$CIPHER' is not available"
        done

        echo -e "\nThis configuration will be stored:\n"
        echo "salt:   $SALT"
        echo "pass:   $PASS"
        echo "cipher: $CIPHER"
        echo -e -n "\nDoes this look right? [Y/n] "
        read answer

        case "$answer" in
            n*|N*)
                # Reconfigure
                unset -v SALT
                unset -v PASS
                unset -v CIPHER
                ;;
            *)
                # Finished
                break
                ;;
        esac
    done

    echo -n "Do you want to use $GIT_DIR/info/attributes? [Y/n] "
    read answer

    local attrs
    case "$answer" in
        n*|N*)
            attrs=".gitattributes"
            ;;
        *)
            attrs="$GIT_DIR/info/attributes"
            ;;
    esac

    local patterns
    echo -n "What files do you want encrypted? [*] "
    read patterns
    [ -z "$patterns" ] && patterns="*"

    set -o noglob
    for pattern in ${patterns}; do
        echo "$pattern filter=encrypt diff=encrypt merge=encrypt" >> $attrs
    done
    set +o noglob
    echo "[merge]" >> $attrs
    echo "    renormalize=true" >> $attrs

    # Encryption
    chmod 600 "$GIT_DIR"/config
    git config gitcrypt.salt "$SALT"
    git config gitcrypt.pass "$PASS"
    git config gitcrypt.cipher "$CIPHER"

    # Filters
    _enable
}

take_pass_from_ssh() {
    #expand ~/file to absolute filepath
    PRIVATE_KEY=$(eval echo "${PASS}" 2> /dev/null)
    if expr "$PRIVATE_KEY" : ".*\.pub" > /dev/null ; then
		#remove .pu extension if any
        PRIVATE_KEY=$(echo "$PRIVATE_KEY" | sed s/.pub//)
		PRIVATE_KEY=`readlink -e "$PRIVATE_KEY"`
    fi

    #decrypt key and start watchdog for unencrypted file
    if [[ -s "$PRIVATE_KEY" ]]; then
        export GITCRYPT_KEY_ENCRYPTED="$PRIVATE_KEY"
        PASS=$(gitcrypt-restore-key) || die "can't decrypt key"
        _debug "= key decrypted"
        unset GITCRYPT_KEY_ENCRYPTED
    fi
}

_clean() {
    # Encrypt using OpenSSL
    take_pass_from_ssh
    openssl enc -base64 -$CIPHER -S "$SALT" -k "$PASS"
}

_smudge() {
    # If decryption fails, use `cat` instead
    take_pass_from_ssh
    openssl enc -d -base64 -$CIPHER -k "$PASS" 2> /dev/null || cat
}

_diff() {
    # If decryption fails, use `cat` instead
    take_pass_from_ssh
    openssl enc -d -base64 -$CIPHER -k "$PASS" -in "$1" 2> /dev/null || cat "$1"
}

_listaffected() {
    # Collect files affected byt crypting(through attributes and files in repo)
    IFS_BACK=$IFS
    IFS="
"
    local GITCRYPT_FILES=$(git ls-tree --name-only --full-tree -r HEAD) || die "Can't collect list of files in repo"
    ARRAY=()
    for x in $GITCRYPT_FILES; do
        git check-attr filter "$x" | grep encrypt &> /dev/null
        if [ $? -eq 0 ]; then
            _debug " - adding file #{$x} to affected list"
            ARRAY+=("$x")
        fi
    done
    export GITCRYPT_AFFECTED_FILES=${ARRAY[@]}
    _debug "= Affected files: \n  [\n`printf -- '  %s\n' \"${GITCRYPT_AFFECTED_FILES[@]}\"`\n  ]"
    IFS=$IFS_BACK
}

_crypthistory_impl() {
    _debug " => Crypting history"
    export GDBGTAB="${GDBGTAB}  "
    _disable
    git reset --hard &> /dev/null
    _listaffected
    git filter-branch --prune-empty --tree-filter "gitcrypt-filter '$0 clean'" -f
    _enable
    git reset --hard &> /dev/null
    export GDBGTAB={GDBGTAB/\ \ /}
}

_crypthistory() {
    echo -n "You MUST run 'crypthistory' BEFORE any encrypted commits."
    echo -n "Do you want to recrypt all history? This may corrut your data? [Y/n]"
    read answer

    case "$answer" in
        n*|N*)
            exit 0
            ;;
        *)
            echo "This may take a while depends on file sizes in repo..."
            ;;
    esac

    _crypthistory_impl
}

_decrypthistory() {
    _debug " => Decrypting history"
    export GDBGTAB="${GDBGTAB}  "
    _disable
    git reset --hard &> /dev/null

    if [ "$1" == "all" ]; then
        export GITCRYPT_AFFECTED_FILES="*"
        _debug "= force decrypt ALL files"
    else
        _listaffected
    fi

    git filter-branch --prune-empty --tree-filter "gitcrypt-filter '$0 smudge'" -f
    git reset --hard &> /dev/null
    export GDBGTAB={GDBGTAB/\ \ /}
}

_recrypt() {
    echo -n "Do you want to change password and recrypt repo with new one? [Y/n]"
    read answer

    case "$answer" in
        n*|N*)
            exit 0
            ;;
        *)
            echo -n "Enter your new passphrase or path to key: "
            read PASS
            ;;
    esac

    _debug "=> Recrypting history"
    export GDBGTAB="${GDBGTAB}  "
    _decrypthistory
    git config gitcrypt.pass "$PASS"
    chmod 600 "$GIT_DIR"/config
    _crypthistory_impl
    export GDBGTAB={GDBGTAB/\ \ /}
}

case "$1" in
    clean|smudge|diff|enable|disable|crypthistory|decrypthistory|recrypt)
        # Need a shared salt
        SALT=$(git config gitcrypt.salt)
        if [ -z "$SALT" ]; then
            die "Gitcrypt: shared salt (gitcrypt.salt) has not been configured"
        fi

        # Need a secure passphrase
        PASS=$(git config gitcrypt.pass)
        if [ -z "$PASS" ]; then
            die "Gitcrypt: secure passphrase (gitcrypt.pass) has not been configured"
        fi

        # And a cipher mode
        CIPHER=$(git config gitcrypt.cipher)
        [ -z "$CIPHER" ] && CIPHER="$DEFAULT_CIPHER"

        # Execute command
        _$1 "$2"
        ;;
    init)
        # Run setup commands
        init_config
        ;;
    version)
        # Show version
        echo "gitcrypt version $VERSION"
        ;;
    *)

        # Not a valid option
        if [ -z "$1" ]; then
            echo "Gitcrypt: available options: init, enable, disable, crypthistory, decrypthistory, recrypt, version"
        else
            echo "Gitcrypt: command does not exist: $1"
        fi
        exit 1
        ;;
esac
exit 0
