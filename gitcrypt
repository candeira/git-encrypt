#!/usr/bin/env sh

readonly VERSION="0.4.1"
readonly DEFAULT_CIPHER="aes-256-cbc"

[ -z "$GIT_DIR" ] && GIT_DIR=".git"

die() {
    echo "Error: $@"
    exit -1
}

check_distr() {
    which "$1" &> /dev/null || die "$1 not found in PATH - check gitcrypt distribution"
}

check_distr "gitcrypt-restore-key"
check_distr "gitcrypt-merge"
check_distr "gitcrypt-watchdog"
check_distr "gitcrypt-filter"

_disable() {
    _debug "=> Disabling gitcrypt facility"
    git config --unset filter.encrypt.smudge
    git config --unset filter.encrypt.clean
    git config --unset filter.encrypt.required
    git config --unset diff.encrypt.textconv

    git config --unset merge.encrypt.name
    git config --unset merge.encrypt.driver
    git config --remove-section filter.encrypt &> /dev/null
    git config --remove-section diff.encrypt &> /dev/null
    git config --remove-section merge.encrypt &> /dev/null
}

_enable() {
    _debug "=> Enabling gitcrypt facility"
    git config filter.encrypt.smudge "gitcrypt smudge"
    git config filter.encrypt.clean "gitcrypt clean"
    git config filter.encrypt.required
    git config diff.encrypt.textconv "gitcrypt diff"

    git config merge.encrypt.name "gitcrypt merge driver"
    git config merge.encrypt.driver "gitcrypt-merge %A %O %B %L"
}

_debug() {
    [ -z "$GITCRYPTDEBUG" ] || echo -e "GCDBG: ${GDBGTAB} ${1}"
}



_generate_masterkey() {
  cat /dev/urandom | LC_ALL="C" tr -dc '!@#$%^&*()_A-Z-a-z-0-9' | head -c64
}

_master() {
  echo "$(git rev-parse --show-toplevel)/.gitcryptmaster" 
}

_encrypt_masterkey() {
  local master=$(_master)
  if [ "$PASS" == "gpg" ]; then
    echo $(_generate_masterkey) | gpg --encrypt --armor > "$master"
  else
    echo $(_generate_masterkey) | openssl enc -base64 -aes-256-cbc -k "$PASS" > "$master"
  fi
}

_decrypt_masterkey() {
  while [ -z "$MKEY" ]; do
	  local master=$(_master)
	  [[ -r "$master" ]] || die "can't read master password $master"
	  if [ "$PASS" == "gpg" ]; then
	    MKEY=$(cat "$master" | gpg --decrypt || die "can't decrypt masterkey")
	  else
		  MKEY=$(openssl enc -d -base64 -aes-256-cbc -k "$PASS" -in "$master" || die "can't decrypt masterkey")
	  fi
  done
}

_salt() {
  local md5=$(which md5 2>/dev/null || which md5sum 2>/dev/null)
  LC_ALL="C" echo "$1" | tr -dc 'a-e-0-9' | $md5 | cut -c-16
}


init_config() {
    local answer

    if [ ! -d "$GIT_DIR" ]; then
        echo "Directory is not a git repository. Did you forget to run 'git init'?"
        return 1
    fi

    while [ 1 ]; do

        while [ -z "$PASS" ]; do
          echo "Please select masterkey encryption type:"
          echo " type 'gpg' for use gpg"
          echo " type path to ssh-private key ex: ~/.ssh/id_rsa"
          echo " or type <passphrase> wich will encrypt masterkey"
          read PASS
        done

        while [ 1 ]; do
            echo -n "What encryption cipher do you want to use? [$DEFAULT_CIPHER] "
            read CIPHER
            [ -z "$CIPHER" ] && CIPHER="$DEFAULT_CIPHER"

            local exists
            exists=$(openssl list-cipher-commands | grep "$CIPHER")
            [ $? -eq 0 ] && break

            echo "Error: Cipher '$CIPHER' is not available"
        done

        echo -e "\nThis configuration will be stored:\n"
        echo "pass:   $PASS"
        echo "cipher: $CIPHER"
        echo -e -n "\nDoes this look right? [Y/n] "
        read answer

        case "$answer" in
            n*|N*)
                # Reconfigure
                unset -v PASS
                unset -v CIPHER
                ;;
            *)
                # Finished
                break
                ;;
        esac
    done

    echo -n "Do you want to use $GIT_DIR/info/attributes? [Y/n] "
    read answer

    local attrs
    case "$answer" in
        n*|N*)
            attrs=".gitattributes"
            ;;
        *)
            attrs="$GIT_DIR/info/attributes"
            ;;
    esac

    local patterns
    echo -n "What files do you want encrypted? [*] "
    read patterns
    [ -z "$patterns" ] && patterns="*"

    set -o noglob
    for pattern in ${patterns}; do
        echo "$pattern filter=encrypt diff=encrypt merge=encrypt" >> $attrs
        echo ".gitcryptmaster filter diff merge text" >> $attrs
        echo ".gitattributes filter diff merge text" >> $attrs
    done
    set +o noglob
    echo "[merge]" >> $attrs
    echo "    renormalize=true" >> $attrs

    # Encryption
    chmod 600 "$GIT_DIR"/config

    if [ ! -r "$(_master)" ]; then
      _encrypt_masterkey
  	  git add $(_master)
  	  git commit -m "master key initilized"
    fi
    take_pass_from_cache

    git config gitcrypt.salt "$(_salt $MKEY)"
    git config gitcrypt.pass "$PASS"
    git config gitcrypt.cipher "$CIPHER"

    # Filters
    _enable
}


take_pass_from_cache() {
    #expand ~/file to absolute filepath
    #PRIVATE_KEY=$(eval echo "${PASS}" 2> /dev/null)
    #if expr "$PRIVATE_KEY" : ".*\.pub" > /dev/null ; then
	#	#remove .pu extension if any
    #    PRIVATE_KEY=$(echo "$PRIVATE_KEY" | sed s/.pub//)
	#	PRIVATE_KEY=`readlink -e "$PRIVATE_KEY"`
    #fi

    #decrypt key and start watchdog for unencrypted file
    #if [[ -s "$PRIVATE_KEY" ]]; then
    #    export GITCRYPT_KEY_ENCRYPTED="$PRIVATE_KEY"
    #    PASS=$(gitcrypt-restore-key) || die "can't decrypt key"
    #    _debug "= key decrypted"
    #    unset GITCRYPT_KEY_ENCRYPTED
    #fi

	export GITCRYPT_KEY_ENCRYPTED=$(_master)
  MKEY=$(gitcrypt-restore-key "$PASS") || die "can't decrypt key"
}

_clean() {
	take_pass_from_cache
	openssl enc -base64 -$CIPHER -S "$SALT" -k "$MKEY"
}

_smudge() {
	take_pass_from_cache
	openssl enc -d -base64 -$CIPHER -k "$MKEY" 2> /dev/null || cat
}

_diff() {
	take_pass_from_cache
	openssl enc -d -base64 -$CIPHER -k "$MKEY" -in "$1" 2> /dev/null || cat "$1"
}

_listaffected() {
    # Collect files affected byt crypting(through attributes and files in repo)
    IFS_BACK=$IFS
    IFS="
"
    local GITCRYPT_FILES=$(git ls-tree --name-only --full-tree -r HEAD) || die "Can't collect list of files in repo"
    ARRAY=()
    for x in $GITCRYPT_FILES; do
        git check-attr filter "$x" | grep encrypt &> /dev/null
        if [ $? -eq 0 ]; then
            _debug " - adding file #{$x} to affected list"
            ARRAY+=("$x")
        fi
    done
    export GITCRYPT_AFFECTED_FILES=${ARRAY[@]}
    _debug "= Affected files: \n  [\n`printf -- '  %s\n' \"${GITCRYPT_AFFECTED_FILES[@]}\"`\n  ]"
    IFS=$IFS_BACK
}

_crypthistory_impl() {
    _debug " => Crypting history"
    export GDBGTAB="${GDBGTAB}  "
    _disable
    git reset --hard &> /dev/null
    _listaffected
    git filter-branch --prune-empty --tree-filter "gitcrypt-filter '$0 clean'" -f
    _enable
    git reset --hard &> /dev/null
    export GDBGTAB={GDBGTAB/\ \ /}
}

_crypthistory() {
    echo -n "You MUST run 'crypthistory' BEFORE any encrypted commits."
    echo -n "Do you want to recrypt all history? This may corrut your data? [Y/n]"
    read answer

    case "$answer" in
        n*|N*)
            exit 0
            ;;
        *)
            echo "This may take a while depends on file sizes in repo..."
            ;;
    esac

    _crypthistory_impl
}

_decrypthistory() {
    _debug " => Decrypting history"
    export GDBGTAB="${GDBGTAB}  "
    _disable
    git reset --hard &> /dev/null

    if [ "$1" == "all" ]; then
        export GITCRYPT_AFFECTED_FILES="*"
        _debug "= force decrypt ALL files"
    else
        _listaffected
    fi

    git filter-branch --prune-empty --tree-filter "gitcrypt-filter '$0 smudge'" -f
    git reset --hard &> /dev/null
    export GDBGTAB={GDBGTAB/\ \ /}
}

_recrypt() {
    echo -n "Do you want to change password and recrypt repo with new one? [Y/n]"
    read answer

    case "$answer" in
        n*|N*)
            exit 0
            ;;
        *)
            echo -n "Enter your new passphrase or path to key: "
            read PASS
            ;;
    esac

    _debug "=> Recrypting history"
    export GDBGTAB="${GDBGTAB}  "
    _decrypthistory
    git config gitcrypt.pass "$PASS"
    chmod 600 "$GIT_DIR"/config
    _crypthistory_impl
    export GDBGTAB={GDBGTAB/\ \ /}
}

case "$1" in
    clean|smudge|diff|enable|disable|crypthistory|decrypthistory|recrypt)
        # Need a shared salt
        SALT=$(git config gitcrypt.salt)
        if [ -z "$SALT" ]; then
            die "Gitcrypt: shared salt (gitcrypt.salt) has not been configured"
        fi

        # Need a secure passphrase
        PASS=$(git config gitcrypt.pass)
        if [ -z "$PASS" ]; then
            die "Gitcrypt: secure passphrase (gitcrypt.pass) has not been configured"
        fi

        # And a cipher mode
        CIPHER=$(git config gitcrypt.cipher)
        [ -z "$CIPHER" ] && CIPHER="$DEFAULT_CIPHER"

        # Execute command
        _$1 "$2"
        ;;
    init)
        # Run setup commands
        init_config
        ;;
    version)
        # Show version
        echo "gitcrypt version $VERSION"
        ;;
    *)

        # Not a valid option
        if [ -z "$1" ]; then
            echo "Gitcrypt: available options: init, enable, disable, crypthistory, decrypthistory, recrypt, version"
        else
            echo "Gitcrypt: command does not exist: $1"
        fi
        exit 1
        ;;
esac
exit 0
